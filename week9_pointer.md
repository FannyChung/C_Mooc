##运算符&
获取变量的地址。
用%p输出。否则会被编译器影响。如下：可以赋值给int。在32位时输出一样（4B），但在64位时候（4B,8B），不同。
取地址不能做运算，只能有变量。

地址与声明的顺序相反。因为是stack存放。

数组：
printf("%p",&a)与printf("%p",a)、printf("%p",&a[0])相等。
##指针变量
指针就是记录地址的变量。`int *p=&i;`
`int *p,q;``int* p,q;`都代表p是指针，q是int。

最好初始化为0。`void *p=0;`
###在函数中使用
def:`void f(int *p)`
call:`f(&i)`

###使用*读写指针指向的变量

##指针应用场景
###交换数据
###返回数据
如果需要函数返回多个数，则可将他们的指针作为参数传入，经过函数修改。
函数返回运算的状态，结果通过指针返回。

##指针与数组
数组变量是特殊的指针。
下面四种原型是等价的：
`int sum(int *ar,int n)`、`int sum(int *，int)`、`int sum(int ar[],int n)`、`int sum(int [],int)`
###指针与const（C99）
指针const:`int* const q=&i;*q=26;~~q++~~`
值const：`const int *p;`

>const在*前：值被const
const在*后：指针被const

数组本身就是const指针，所以const的数组是值const.

##指针计算
指针与整数：+,-,+=,-=
递增、递减：++，--
指针与指针：-
都是基于个数的。
指针可作比较。
NULL表示0地址。
指向不同类型的指针不要相互赋值，因为修改指针内容可能修改了不同的范围。

ps：
*p++:先做p++，后置，返回p并取p的值，最后指针前移++.
##指针的作用
传入较大数据的参数
传入数组并对其操作
返回不止一个结果，函数修改不止一个变量
动态申请内存

##动态分配内存
根据输入声明数组大小，C99之前要`int *a =(int*)malloc(n*sizeof(int))`。要`#include<stdlib.h>`。

释放：`free(a)`。
如果不释放，程序关闭会自动回收，但是长时间运行的程序和大程序会有很大的影响。

> Written with
 [StackEdit](https://stackedit.io/).
